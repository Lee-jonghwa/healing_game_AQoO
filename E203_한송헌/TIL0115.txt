아이디어 회의

모션 사격

플레이어가 신체 동작으로 사격과 회피를 수행하며 목표를 달성하는 웹 기반 게임입니다. 실감 나는 모션 플레이와 화상 채팅을 통해 경쟁과 협동의 재미를 제공합니다.

게임 주요 기능

1. **화상 채팅:**
    - 게임 중 실시간으로 플레이어들의 표정과 동작을 화상으로 볼 수 있음.
    - 팀원들과의 전략 소통 가능.
2. **모션 인식:**
    - 카메라를 통해 플레이어의 팔, 손, 몸의 움직임을 인식하여 조작.
    - 예시:
        - 손가락 모양으로 총을 쏘는 동작.
        - 몸을 좌우로 움직여 장애물을 회피.
3. **AI 판정:**
    - 플레이어 동작의 정확도와 속도를 판정하여 점수 부여.

---

게임 플레이 방식

### 1. **싱글 플레이 모드**

- **목표:**
    - 스테이지마다 주어지는 목표(적 제거, 표적 맞히기 등)를 완수.
- **조작 방법:**
    - 손가락으로 총을 형성하고 사격 동작 수행.
    - 손가락이 움직이는 속도를 분석해 발사 타이밍을 계산.
    - 몸을 좌우로 움직이며 장애물 회피.
- **보너스 요소:**
    - 정확한 헤드샷이나 연속 사격 시 추가 점수 획득.

### 2. **멀티플레이 모드**

- **목표:**
    - 협력하여 보스 처치 또는 적 팀과 대결.
    - 경쟁 모드에서는 사격 정확도와 생존 시간이 점수에 반영.
- **모드 종류:**
    - **협동 모드:** 팀원들과 협력해 몰려오는 적 물결을 방어.
    - **대결 모드:** 다른 팀과 실시간 점수 대결.

---

게임 규칙

1. **사격 방식:**
    - 카메라에 손가락 총 모양을 인식하여 사격.
    - 사격 정확도가 점수에 반영.
2. **회피와 이동:**
    - 플레이어의 좌우 움직임으로 장애물 회피.
    - 스쿼트나 점프로 특정 공격 회피.

---

추가 기능

1. **캐릭터 커스터마이징:**
    - 플레이어의 아바타를 꾸밀 수 있는 다양한 옵션 제공.
    - 장비 업그레이드 및 무기 스킨 획득 가능.
2. **리더보드:**
    - 글로벌 리더보드에서 점수 비교 가능.
    - 주간 이벤트를 통해 상위 플레이어에게 보상 제공.
3. **특수 아이템:**
    - 플레이 도중 아이템을 획득하여 체력 회복, 사격 속도 증가 등 효과 발동.

---

사용 기술

- **화상 데이터 분석**
    - **손 모양 인식**
    - **위치 추적**
- **게임 화면 렌더링 및 공유**
    - **화면 공유**
    - **게임 타겟 매핑**
- **실시간 네트워킹**
    - **플레이어 입력 동기화**
- **AI 사격 판정**

---

기술 스택

### **1. WebGL**

- **사용 기능**:
    - 게임 화면의 2D 또는 3D 그래픽 렌더링.
    - `Three.js`를 사용하여 타겟, 배경, 총알 등의 그래픽 작업 간소화.
- **난이도**: **중간**
    - WebGL 자체는 복잡한 수학적 계산(좌표 변환, 셰이더 작성 등)을 요구하지만, `Three.js`는 이를 추상화하여 사용하기 쉽게 만듦.
- **필요한 배경**:
    - 3D 그래픽과 렌더링 기본 개념(카메라, 조명, 메시, 텍스처 등).
    - JavaScript와 라이브러리 사용 경험.

---

### **2. WebSocket**

- **사용 기능**:
    - 클라이언트-서버 간 실시간 데이터 송수신.
    - 타겟 명중 이벤트, 사용자 손 모양 데이터를 서버로 전달.
- **난이도**: **쉬움**
    - WebSocket은 비교적 단순한 프로토콜이며, `Socket.IO`는 이를 쉽게 설정할 수 있는 라이브러리.
- **필요한 배경**:
    - HTTP와 WebSocket의 차이 이해.
    - JavaScript 비동기 처리 경험(Promise, Async/Await).

---

### **3. Database**

### MongoDB

- **사용 기능**:
    - 유저 정보와 점수, 게임 데이터 저장.
- **난이도**: **쉬움**
    - 문서 기반 데이터베이스로 직관적인 CRUD 작업 가능.
- **필요한 배경**:
    - NoSQL 데이터베이스 기본 개념.
    - 데이터 모델링과 쿼리 작성 능력.

### Redis

- **사용 기능**:
    - 게임 상태 동기화, 실시간 캐싱.
- **난이도**: **중간**
    - Redis는 기본 사용법은 간단하지만, 동시성 및 만료 키 관리 등을 잘 설계해야 함.
- **필요한 배경**:
    - Key-Value 데이터 저장소 개념 이해.
    - 캐싱 전략과 TTL 설정 경험.

---

### **4. REST / GraphQL API**

- **사용 기능**:
    - 게임 상태(현재 타겟 위치 등)와 사용자 데이터 전송.
- **난이도**: **쉬움 ~ 중간**
    - REST는 간단하지만, GraphQL은 쿼리 및 스키마 설계가 필요하므로 더 복잡.
- **필요한 배경**:
    - API 설계 원칙과 HTTP 메서드(GET, POST 등).
    - GraphQL의 쿼리 언어와 스키마 정의 이해(선택적).

---

### **5. MediaPipe**

- **사용 기능**:
    - 손 모양 및 위치 실시간 추적.
    - 손가락의 관절 데이터를 추출하여 사격 모션 판별.
- **난이도**: **중간**
    - MediaPipe는 사전 학습된 모델을 제공해 간단히 시작 가능하지만, 고정밀 동작 인식과 좌표 매핑은 추가 작업 필요.
- **필요한 배경**:
    - 컴퓨터 비전 기초 개념(좌표 시스템, 영상 처리).
    - 머신러닝 모델 사용 경험(기본).

---

### **6. TensorFlow.js**

- **사용 기능**:
    - 브라우저에서 머신러닝 모델 실행 및 동작 분류.
- **난이도**: **중간 ~ 어려움**
    - 간단한 모델은 쉽게 실행 가능하지만, 사용자 정의 동작을 인식하려면 추가 모델 학습이 필요.
- **필요한 배경**:
    - 머신러닝 기본 지식(훈련 데이터, 분류 알고리즘).
    - TensorFlow 모델 로딩 및 브라우저 환경에서의 사용 경험.

---

### **7. OpenCV.js**

- **사용 기능**:
    - 화상 데이터 전처리(배경 제거, 손 모양 명확화).
    - 손 좌표와 화면 타겟 매핑 처리.
- **난이도**: **중간**
    - OpenCV는 강력하지만, JavaScript 환경에서 사용 시 퍼포먼스 최적화 필요.
- **필요한 배경**:
    - 이미지 처리 기초(필터링, 경계 추출 등).
    - OpenCV 함수 사용 경험.

---

### **8. WebRTC**

- **사용 기능**:
    - 실시간 화상 채팅 및 화면 공유.
- **난이도**: **중간**
    - 기본 화상 채팅과 P2P 연결은 간단하지만, 멀티플레이어 동기화와 데이터 전송은 복잡.
- **필요한 배경**:
    - 네트워크 통신 개념(P2P, Signaling).
    - WebRTC API 사용 경험.

---

### **9. Signaling Server**

- **사용 기능**:
    - WebRTC 연결을 설정하기 위한 초기 메시지 교환(시그널링).
- **난이도**: **쉬움 ~ 중간**
    - Node.js와 `Socket.IO`를 사용하면 쉽게 구현 가능.
- **필요한 배경**:
    - WebRTC 연결 설정 과정 이해(ICE Candidate, SDP).
    - 서버와 클라이언트 통신 기본 개념.